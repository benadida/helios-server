<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" />
  <title>Helios Voting Booth</title>
  <link rel="stylesheet" type="text/css" href="css/booth.css" />
  <link rel="stylesheet" type="text/css" href="css/forms.css" />
  
<!--  <script language="javascript" src="js/20160507-helios-booth-compressed.js"></script> -->

<script language="javascript" src="js/jscrypto/sjcl.js"></script>
<script language="javascript" src="js/jscrypto/jsbn.js"></script>
<script language="javascript" src="js/jscrypto/jsbn2.js"></script>
<script language="javascript" src="js/jscrypto/sha1.js"></script>
<script language="javascript" src="js/jscrypto/sha2.js"></script>
<script language="javascript" src="js/jscrypto/bigint.js"></script>
<script language="javascript" src="js/jscrypto/class.js"></script>
<script language="javascript" src="js/jscrypto/elgamal.js"></script>
<script language="javascript" src="js/jscrypto/helios.js"></script>


</head>
<body>
<div id="wrapper">
<span style="float:right; padding: 7px 15px 5px 10px;">[<a href="javascript:BOOTH.exit();">exit</a>]</span>
<div id="banner">Helios Voting Booth</div>
<div id="content">

<div id="header">
</div>

<script language="javascript">
// const USE_SJCL = true;

/*  
Create web-worker from blob 
*/

var blob = new Blob([`
var console = {"log" : function(msg) {self.postMessage({"type":"log","msg":msg});}};
var ELECTION = null;
//var HELIOS;
function do_setup(message) {
  console.log("this: " + JSON.stringify(this));
  console.log("setting up worker");
  ELECTION = HELIOS.Election.fromJSONString(message.election);
} 
function do_encrypt(message) {
  console.log("encrypting answer for question " + ELECTION.questions[message.q_num]); 
  var encrypted_answer = new HELIOS.EncryptedAnswer(ELECTION.questions[message.q_num], message.answer, ELECTION.public_key);
  console.log("done encrypting");
  self.postMessage({"type": "result","q_num": message.q_num,"encrypted_answer": encrypted_answer.toJSONObject(true),"id":message.id});
} 

self.onmessage = function(event) {
  console.log("this: " + JSON.stringify(this));
  console.log("globalThis " + JSON.stringify(globalThis));
  if (event.data.type === "import") {
    var data = event.data;  
    if (data.heliosBlobUrl) {
      console.log("Url for heliosBlobUrl " + data.heliosBlobUrl);
      importScripts(data.heliosBlobUrl);
    }      
  }
  else if (event.data.type === "setup") {
    console.log("election data: " + JSON.stringify(event.data.election));
    do_setup(event.data);
  } 
  else if (event.data.type === "encrypt") {
    console.log("Blob encrypting: ");
    do_encrypt(event.data); 
  }
};
`]);



BOOTH = {};

window.onload = function() {
  console.log('Onload.....');
  if (document.readyState != 'loading'){
    startSetup();
  } else {
    document.addEventListener('DOMContentLoaded', startSetup);
  }
}


window.onbeforeunload = function(evt) {
  if (!BOOTH.started_p)
    return;

  if (typeof evt == 'undefined') {
    evt = window.event;
  }

  var message = "If you leave this page with an in-progress ballot, your ballot will be lost.";

  if (evt) {
    evt.returnValue = message;
  }

  return message;
};


BOOTH.started_p = false;

BOOTH.exit = function() {
    if (confirm("Are you sure you want to exit the booth and lose all information about your current ballot?")) {
        BOOTH.started_p = false;
        window.location = BOOTH.election.cast_url;
    }
};

/*
Entry point

*/

function startSetup() {
  console.log('Here.......')
  if (USE_SJCL) {
      sjcl.random.startCollectors();
    }

    // we're asynchronous if we have SJCL and Worker
    BOOTH.synchronous = !(USE_SJCL && window.Worker);

    // we do in the browser only if it's asynchronous
    BigInt.in_browser = !BOOTH.synchronous;

    // set up dummy bigint for fast parsing and serialization
    if (!BigInt.in_browser)
      BigInt = BigIntDummy;

    BigInt.setup(BOOTH.so_lets_go);
}


BOOTH.so_lets_go = function () {
    BOOTH.hide_progress();
    // BOOTH.setup_templates();

    // election URL
    const urlParams = new URLSearchParams(window.location.search);
    var election_url = urlParams.get('election_url');
    BOOTH.load_and_setup_election(election_url);
};

BOOTH.ready_p = false;

BOOTH.load_and_setup_election = function(election_url) {
    // the hash will be computed within the setup function call now
    // Get election json data
    var request = new XMLHttpRequest();
    request.open('GET', election_url, true);
    request.onload = function() {
      var raw_json = this.response;
      // Get metadata
      var request_meta = new XMLHttpRequest();
      request_meta.open('GET', election_url + "meta", true);
      request_meta.onload = function() {
        var election_metadata = JSON.parse(this.response);
        BOOTH.election_metadata = election_metadata;
        BOOTH.setup_election(raw_json, election_metadata);
        BOOTH.show_election();
        BOOTH.election_url = election_url;
      }
      request_meta.send();
    };
    request.send();

    // WM: TODO

    if (USE_SJCL) {
    //   // get more randomness from server
    //   $.get(election_url + "get-randomness", {}, function(raw_json) {
    //     sjcl.random.addEntropy(JSON.parse(raw_json).randomness);
    //   });
    }
};

BOOTH.setup_election = function(raw_json, election_metadata) {
  // IMPORTANT: we use the raw JSON for safer hash computation
  // so that we are using the JSON serialization of the SERVER
  // to compute the hash, not the JSON serialization in JavaScript.
  // the main reason for this is unicode representation: the Python approach
  // appears to be safer.
  BOOTH.election = HELIOS.Election.fromJSONString(raw_json);

  // FIXME: we shouldn't need to set both, but right now we are doing so
  // because different code uses each one. Bah. Need fixing.
  BOOTH.election.hash = b64_sha256(raw_json);
  BOOTH.election.election_hash = BOOTH.election.hash;
  
  BOOTH.setup_workers(raw_json);

  document.title += ' - ' + BOOTH.election.name;

  // WM: TODO
  // escape election fields
  // $(['description', 'name']).forEach(function(field, i) {
  //   BOOTH.election[field] = escape_html(BOOTH.election[field]);
  // });

  // ['description', 'name'].forEach(function(field, i) {
  //   BOOTH.election[field] = escape_html(BOOTH.election[field]);
  // });


  // whether the election wants candidate order randomization or not
  // we set up an ordering array so that the rest of the code is
  // less error-prone. 
  BOOTH.election.question_answer_orderings = [];
  BOOTH.election.questions.forEach(function(question, i ) {
    var ordering = new Array(question.answers.length);

    // initialize array so it is the identity permutation
    (ordering).forEach(function(answer, j) {ordering[j]=j;});

    // if we want reordering, then we shuffle the array
    if (election_metadata && election_metadata.randomize_answer_order) {
      shuffleArray(ordering);
    }

    BOOTH.election.question_answer_orderings[i] = ordering;
  });

  var objects = BOOTH.election.questions;
  Array.prototype.forEach.call(objects, function(question, i) {
    // initialize array so it is the identity permutation
    // $(ordering).each(function(j, answer) {ordering[j]=j;});
    // var elements = document.querySelectorAll(ordering);
    // Array.prototype.forEach.call(elements, function(answer, j){ordering[j]=j;});
    var ordering = [];
    let ln = question.answers.length;
    for (var j = 0; j < ln; ++j) {
      ordering[j] = j;
    }
    // if we want reordering, then we shuffle the array
    if (election_metadata && election_metadata.randomize_answer_order) {
      shuffleArray(ordering);
    }

    BOOTH.election.question_answer_orderings[i] = ordering;
  });
  
  setupHeaderFooterDivs();
  BOOTH.setup_ballot();
};


BOOTH.setup_workers = async function(election_raw_json) {

  if (!BOOTH.synchronous) {
      // Set up window worker
      const blobURL = window.URL.createObjectURL(blob);
      // Import crypto scripts
      const heliosBlobScript = await import('./js/blobs.js');
      const heliosBlob = new Blob([heliosBlobScript.heliosBlob], {type: 'application/javascript'});
      const heliosBlobUrl = window.URL.createObjectURL(heliosBlob);
      console.log("heliosBlob: ", heliosBlob)
      // prepare spots for encrypted answers
      // and one worker per question 
      BOOTH.encrypted_answers = [];
      BOOTH.answer_timestamps = [];
      BOOTH.worker = new Worker(blobURL);
      console.log("raw HELIOS: ", HELIOS);
      BOOTH.worker.postMessage({'type': 'import', url: window.document.URL, heliosBlobUrl: heliosBlobUrl});
      BOOTH.worker.postMessage({
        'type': 'setup',
        'election' : election_raw_json
      });

      BOOTH.worker.onmessage = function(event) {
        // logging
        if (event.data.type == 'log')
          return BOOTH.log(event.data.msg);

        // result of encryption
        if (event.data.type == 'result') {
          // this check ensures that race conditions
          // don't screw up votes.
          if (event.data.id == BOOTH.answer_timestamps[event.data.q_num]) {
            BOOTH.encrypted_answers[event.data.q_num] = HELIOS.EncryptedAnswer.fromJSONObject(event.data.encrypted_answer, BOOTH.election);
            BOOTH.log("got encrypted answer " + BOOTH.encrypted_answers[event.data.q_num]);
          } else {
            BOOTH.log("no way jose");
          }
        }
      };

    // $(BOOTH.election.questions).each(function(q_num, q) {
    //   BOOTH.encrypted_answers[q_num] = null;
    // });
    // Convert from jquery per http://youmightnotneedjquery.com
    var objects = BOOTH.election.questions;
    Array.prototype.forEach.call(objects, function(q, q_num) {
      BOOTH.encrypted_answers[q_num] = null;
    });
  }
};


BOOTH.setup_ballot = function(election) {
  BOOTH.ballot = {};

  // dirty markers for encryption (mostly for async)
  BOOTH.dirty = [];

  // each question starts out with an empty array answer
  // and a dirty bit to make sure we encrypt
  BOOTH.ballot.answers = [];
  //$(BOOTH.election.questions).each(function(i,x){
  //var elements = document.querySelectorAll(BOOTH.election.questions);
  Array.prototype.forEach.call(BOOTH.election.questions, function(x, i){
    BOOTH.ballot.answers[i] = [];
    BOOTH.dirty[i] = true;
  });
};

BOOTH.show_election = function() {
  setupElectionDiv();
};

BOOTH.show_question = function(questionNum) {
  question_num = questionNum;
  BOOTH.started_p = true;

  // the first time we hit the last question, we enable the review all button
  if (question_num == BOOTH.election.questions.length - 1)
    BOOTH.all_questions_seen = true;

  BOOTH.show_progress('1');
  /*
    BOOTH.show($('#question_div')).processTemplate({'question_num' : question_num,
                        'last_question_num' : BOOTH.election.questions.length - 1,
                        'question' : BOOTH.election.questions[question_num], 'show_reviewall' : BOOTH.all_questions_seen,
            'answer_ordering': BOOTH.election.question_answer_orderings[question_num]
                  });
  */

  setupQuestionDiv();

  // fake clicking through the answers, to trigger the disabling if need be
  // first we remove the answers array
  var answer_array = BOOTH.ballot.answers[question_num];
  BOOTH.ballot.answers[question_num] = [];

  // we should not set the dirty bit here, so we save it away
  var old_dirty = BOOTH.dirty[question_num];
  // $(answer_array).each(function(i, ans) {
  //var elements = document.querySelectorAll(answer_array);
  Array.prototype.forEach.call(answer_array, function(ans, i){
    BOOTH.click_checkbox_script(question_num, ans, true);
  });
  BOOTH.dirty[question_num] = old_dirty;
};

BOOTH.show_progress = function(step_num) {
  document.getElementById('progress_div').style.display = '';
  ['1','2','3'].forEach(function(step){
    const el = document.getElementById('progress_' + step)
    if (step == step_num) {
      el.classList.remove('unselected');
      el.classList.add('selected');
    }
    else {
      el.classList.remove('selected');
      el.classList.add('unselected');
    }
  });
};


BOOTH.hide_progress = function() {
  document.getElementById('progress_div').display = 'none';
};

BOOTH.show_processing_before = function(str_to_execute) {
    document.getElementById('processing_div').innerHTML = "<h3 align='center'>Processing...</h3>";
    BOOTH.show(document.getElementById('processing_div'));

    // add a timeout so browsers like Safari actually display the processing message
    setTimeout(str_to_execute, 250);
};

BOOTH.click_checkbox = function(question_num, answer_num, checked_p) {
  // keep track of dirty answers that need encrypting
  BOOTH.dirty[question_num] = true;

  if (checked_p) {
    // multiple click events shouldn't screw this up
    //if ($(BOOTH.ballot.answers[question_num]).index(answer_num) == -1)
    if ((BOOTH.ballot.answers[question_num]).indexOf(answer_num) == -1)
        BOOTH.ballot.answers[question_num].push(answer_num);

    //$('#answer_label_' + question_num + "_" + answer_num).addClass('selected');
    let el = document.getElementById('answer_label_' + question_num + "_" + answer_num);
    if (el.classList)
      el.classList.add('selected');
    else
      el.className = 'selected';
  } else {
    BOOTH.ballot.answers[question_num] = UTILS.array_remove_value(BOOTH.ballot.answers[question_num], answer_num);
    let el = document.getElementById('answer_label_' + question_num + "_" + answer_num);
    el.classList.remove('selected');
    //$('#answer_label_' + question_num + "_" + answer_num).removeClass('selected');
  }

  if (BOOTH.election.questions[question_num].max != null && BOOTH.ballot.answers[question_num].length >= BOOTH.election.questions[question_num].max) {
    // disable the other checkboxes
    // $('.ballot_answer').each(function(i, checkbox) {
    //     if (!checkbox.checked)
    //         checkbox.disabled = true;
    // });
    let elements = document.querySelectorAll('.ballot_answer');
    Array.prototype.forEach.call(elements, function(checkbox, i){
        if (!checkbox.checked)
            checkbox.disabled = true;
    });

    // do the warning only if the question allows more than one option, otherwise it's confusing
    if (BOOTH.election.questions[question_num].max > 1) {
        document.getElementById('warning_box').innerHTML = "Maximum number of options selected.<br />To change your selection, please de-select a current selection first.";
    }
  } else {
    // enable the other checkboxes
    // $('.ballot_answer').each(function(i, checkbox) {
    //   checkbox.disabled = false;
    // });
    let elements = document.querySelectorAll('.ballot_answer');
    Array.prototype.forEach.call(elements, function(checkbox, i) {
        if (!checkbox.checked)
            checkbox.disabled = false;
    });

    // $('#warning_box').html("");
    document.getElementById('warning_box').innerHTML = "";

  }
};

BOOTH.next = function(question_num) {
    if (BOOTH.validate_question(question_num)) {
        BOOTH.show_question(question_num + 1);
    }
};

BOOTH.previous = function(question_num) {
    if (BOOTH.validate_question(question_num)) {
        BOOTH.show_question(question_num - 1);
    }
};

BOOTH.validate_and_confirm = function(question_num) {
  if (BOOTH.validate_question(question_num)) {
      BOOTH.seal_ballot();
  }
};
    

// check if the current question is ok
BOOTH.validate_question = function(question_num) {
    // check if enough answers are checked
    if (BOOTH.ballot.answers[question_num].length < BOOTH.election.questions[question_num].min) {
        alert('You need to select at least ' + BOOTH.election.questions[question_num].min + ' answer(s).');
        return false;
    }

    // if we need to launch the worker, let's do it
    if (!BOOTH.synchronous) {
      // we need a unique ID for this to ensure that old results
      // don't mess things up. Using timestamp.
      // check if dirty
      if (BOOTH.dirty[question_num]) {
        BOOTH.launch_async_encryption_answer(question_num);
      }
    }
    return true;
};

BOOTH.launch_async_encryption_answer = function(question_num) {
  BOOTH.answer_timestamps[question_num] = new Date().getTime();
  BOOTH.encrypted_answers[question_num] = null;
  BOOTH.dirty[question_num] = false;
  BOOTH.worker.postMessage({
      'type' : 'encrypt',
      'q_num': question_num,
      'answer' : BOOTH.ballot.answers[question_num],
      'id' : BOOTH.answer_timestamps[question_num]
  });
};

// all ciphertexts to null
BOOTH.reset_ciphertexts = function() {
      // Converted
      (BOOTH.encrypted_answers).forEach(function(enc_answer, ea_num) {
        BOOTH.launch_async_encryption_answer(ea_num);
      });
    };

BOOTH.seal_ballot = function() {
    BOOTH.show_progress('2');

    // if we don't have the ability to do crypto in the browser,
    // we use the server
    if (!BigInt.in_browser) {
      BOOTH.show_encryption_message_before(BOOTH.request_ballot_encryption, true);
    } else {
      BOOTH.show_encryption_message_before(BOOTH.seal_ballot_raw, true);
      // $('#percent_done_container').show();
      let el = document.getElementById('percent_done_container');
      el.style.display = '';
    }
};

// BOOTH.request_ballot_encryption = function() {
//     $.post(BOOTH.election_url + "/encrypt-ballot", {'answers_json': $.toJSON(BOOTH.ballot.answers)}, function(result) {
//       //BOOTH.encrypted_ballot = HELIOS.EncryptedVote.fromJSONObject($.secureEvalJSON(result), BOOTH.election);
//       // rather than deserialize and reserialize, which is inherently slow on browsers
//       // that already need to do network requests, just remove the plaintexts

//       BOOTH.encrypted_ballot_with_plaintexts_serialized = result;
//       var ballot_json_obj = $.secureEvalJSON(BOOTH.encrypted_ballot_with_plaintexts_serialized);
//       var answers = ballot_json_obj.answers;
//       for (var i=0; i<answers.length; i++) {
//          delete answers[i]['answer'];
//          delete answers[i]['randomness'];
//       }

//       BOOTH.encrypted_ballot_serialized = JSON.stringify(ballot_json_obj);

//       window.setTimeout(BOOTH._after_ballot_encryption, 0);
//     });
// };

BOOTH.seal_ballot_raw = function() {
    if (BOOTH.synchronous) {
      BOOTH.progress = new UTILS.PROGRESS();
      var progress_interval = setInterval("BOOTH.check_encryption_status()", 500);
      BOOTH.encrypted_ballot = new HELIOS.EncryptedVote(BOOTH.election, BOOTH.ballot.answers, BOOTH.progress);
      clearInterval(progress_interval);
      BOOTH._after_ballot_encryption();
    } else {
      BOOTH.total_cycles_waited = 0;
      BOOTH.wait_for_ciphertexts();
    }
};

BOOTH.total_cycles_waited = 0;

BOOTH.check_encryption_status = function() {
  var progress = BOOTH.progress.progress();
  if (progress == "" || progress == null)
    progress = "0";

  document.getElementById('percent_done').innerHTML = progress;
};


// wait for all workers to be done
BOOTH.wait_for_ciphertexts = function() {
    BOOTH.total_cycles_waited += 1;

    //var answers_done = _.reject(BOOTH.encrypted_answers, _.isNull);
    var answers_done = [];
    BOOTH.encrypted_answers.forEach(function(item, i) {
      if (item !== null) {
        answers_done.push(item)
      }
    })
    var percentage_done = Math.round((100 * answers_done.length) / BOOTH.encrypted_answers.length);

    if (BOOTH.total_cycles_waited > 250) {
      alert('there appears to be a problem with the encryption process.\nPlease email help@heliosvoting.org and indicate that your encryption process froze at ' + percentage_done + '%');
      return;
    }

    if (percentage_done < 100) {
      setTimeout(BOOTH.wait_for_ciphertexts, 500);
      // $('#percent_done').html(percentage_done + '');
      document.getElementById('percent_done').innerHTML = percentage_done + '';
      return;
    }

    BOOTH.encrypted_ballot = HELIOS.EncryptedVote.fromEncryptedAnswers(BOOTH.election, BOOTH.encrypted_answers);

    BOOTH._after_ballot_encryption();
};

BOOTH._after_ballot_encryption = function() {
    // if already serialized, use that, otherwise serialize
    BOOTH.encrypted_vote_json = BOOTH.encrypted_ballot_serialized || JSON.stringify(BOOTH.encrypted_ballot.toJSONObject());

    var do_hash = function() {
      BOOTH.encrypted_ballot_hash = b64_sha256(BOOTH.encrypted_vote_json); // BOOTH.encrypted_ballot.get_hash();
      window.setTimeout(show_cast, 0);
    };

    var show_cast = function() {
      setupSealDiv()
    };

    window.setTimeout(do_hash, 0);
};

BOOTH.show_encryption_message_before = function(func_to_execute) {
    BOOTH.show_progress('2');
    // BOOTH.show($('#encrypting_div'));
    let el = document.getElementById('encrypting_div');
    BOOTH.show(el);
    func_to_execute();
};

BOOTH.audit_ballot = function() {
    // BOOTH.audit_trail = BOOTH.encrypted_ballot_with_plaintexts_serialized || $.toJSON(BOOTH.encrypted_ballot.get_audit_trail());
    BOOTH.audit_trail = BOOTH.encrypted_ballot_with_plaintexts_serialized ||  JSON.stringify(BOOTH.encrypted_ballot.get_audit_trail())
    //BOOTH.show($('#audit_div')).processTemplate({'audit_trail' : BOOTH.audit_trail, 'election_url' : BOOTH.election_url});
    setupAuditDiv()
};

BOOTH.post_audited_ballot = function() {
  // $.post(BOOTH.election_url + "/post-audited-ballot", {'audited_ballot': BOOTH.audit_trail}, function(result) {
  //   alert('This audited ballot has been posted.\nRemember, this vote will only be used for auditing and will not be tallied.\nClick "back to voting" and cast a new ballot to make sure your vote counts.');
  // });
  var request = new XMLHttpRequest();
  request.open('POST', BOOTH.election_url + "/post-audited-ballot", true);
  request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
  request.send("audited_ballot="+ BOOTH.audit_trail);
  request.onload = function() {
    alert('This audited ballot has been posted.\nRemember, this vote will only be used for auditing and will not be tallied.\nClick "back to voting" and cast a new ballot to make sure your vote counts.');
  }
};

BOOTH.cast_ballot = function() {
    // show progress spinner
    document.getElementById('loading_div').style.display = '';
    document.getElementById('proceed_button').setAttribute('disabled', 'disabled'); 

    // at this point, we delete the plaintexts by resetting the ballot
    BOOTH.setup_ballot(BOOTH.election);

    // clear the plaintext from the encrypted
    if (BOOTH.encrypted_ballot)
      BOOTH.encrypted_ballot.clearPlaintexts();

    BOOTH.encrypted_ballot_serialized = null;
    BOOTH.encrypted_ballot_with_plaintexts_serialized = null;

    // remove audit trail
    BOOTH.audit_trail = null;

    // we're ready to leave the site
    BOOTH.started_p = false;

    // submit the form
    // $('#send_ballot_form').submit();
    document.getElementById('send_ballot_form').submit();
};

BOOTH.show_receipt = function() {
    UTILS.open_window_with_content("Your smart ballot tracker for " + BOOTH.election.name + ": " + BOOTH.encrypted_ballot_hash);
};

BOOTH.do_done = function() {
  BOOTH.started_p = false;
};

  /*  
  Setups for creating dynamic components in respective divs 
 */

  async function setupElectionDiv() {
    const election = await import('./templates/election.js');
    document.getElementById('election_div').innerHTML = election.election_markup;
  }

  async function setupHeaderFooterDivs() {
    const header = await import('./templates/header.js');
    document.getElementById('header').innerHTML = header.header_markup;
    const footer = await import('./templates/footer.js');
    document.getElementById('footer').innerHTML = footer.footer_markup;
  }

  async function setupQuestionDiv() {
    question = BOOTH.election.questions[question_num];
    let els = document.getElementsByClassName('panel');
    var i;
    for (i = 0; i < els.length; i++) {
      els[i].style.display = 'none';
    }
    const question_div = await import('./templates/question.js');
    document.getElementById('question_div').innerHTML = question_div.question_markup(question_num);
    document.getElementById('question_div').style.display = 'block';
  }

  async function setupSealDiv() {
    choices = BALLOT.pretty_choices(BOOTH.election, BOOTH.ballot);
    const seal_div = await import('./templates/seal.js');
    document.getElementById('seal_div').innerHTML = seal_div.seal_markup; 
    BOOTH.show(document.getElementById('seal_div'));
    BOOTH.encrypted_vote_json = null;
  }

  async function setupAuditDiv() {
    const audit_div = await import('./templates/audit.js');
    document.getElementById('audit_div').innerHTML = audit_div.auditdiv_markup; 
    BOOTH.show(document.getElementById('audit_div'));
  }

  /*
  Utils
  */

  BOOTH.log = function(msg) {
    if (typeof(console) != undefined)
      console.log(msg);
  }; 

  BOOTH.show = function(el) {
    let els = document.getElementsByClassName('panel');
    Array.prototype.forEach.call(els, function(div, i){
      div.style.display = 'none';
    })
    el.style.display = 'block';
  };

  // WM: TODO:
  function escape_html(content) {
    // return $('<div/>').text(content).html();
    return document.querySelector('div').textContent = content;
  }
  
function shuffleArray(array) {
  var currentIndex = array.length
    , temporaryValue
    , randomIndex
    ;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {
     // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}


</script>

<div id="page">
  <div id="progress_div" style="display:none; width: 500px; margin:auto;">
      <table width="100%">
          <tr><td id="progress_1">(1) Select</td><td id="progress_2">(2) Review</td><td id="progress_3">(3) Submit</td></tr>
      </table>
  </div>
  <div id="election_div" class="panel">
    <h3>Checking capabilities and loading election booth...</h3>
    <div align="center"><img src="loading.gif" /><br />This may take up to 10 seconds</div>
  </div>

  <div id="error_div" class="panel" style="display: none;">
    <h3>There's a problem</h3>
    <p>
      It appears that your browser does not have Java enabled. Helios needs Java to perform encryption within the browser.
    </p>
    <p>
      You may be able to install Java by visiting <a target="_new" href="http://java.com">java.com</a>.
    </p>
  </div>

  <div id="question_div" class="panel">
  </div>

  <div id="processing_div" class="panel" style="display:none;">
      <h3 align="center">Processing....</h3>
  </div>

  <div id="encrypting_div" class="panel" style="display:none;">
      <h3 align="center">Helios is now encrypting your ballot<br />
          <img src="encrypting.gif" /> <span style="font-size:0.7em; display:none;" id="percent_done_container">(<span id="percent_done">0</span>%)</span></h3>

      <p align="center"><b>This may take up to two minutes.</b>
  </div>

  <div id="seal_div" class="panel">
  </div>

  <div id="audit_div" class="panel">
  </div>

</div>

<br clear="both" />
</div>
<div id="footer">&nbsp;</div>
</div>
<div id="applet_div">
</div>
</body>
</html>
